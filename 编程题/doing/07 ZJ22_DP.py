'''
ZJ22 毕业旅行

https://www.nowcoder.com/practice/3d1adf0f16474c90b27a9954b71d125d?tpId=137&tags=&title=&diffculty=0&judgeStatus=0&rp=0&tab=answerKey

题目描述

小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，
然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。
由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。
给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

输入描述:

城市个数n（1<n≤20，包括北京）

城市间的车票价钱 n行n列的矩阵 m[n][n]

输出描述:

最小车费花销 s

示例1
输入

4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0

输出

13

说明

共 4 个城市，城市 1 和城市 1 的车费为0，城市 1 和城市 2 之间的车费为 2，
城市 1 和城市 3 之间的车费为 6，城市 1 和城市 4 之间的车费为 5，依次类推。
假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。

'''

'''
动态规划：将一个问题分解为相同性质的子问题，从而逐渐降低求解范围，直至问题可以直接求解。

通常用于求解具有某种最优性质的问题，其基本思想是将待求解问题分解成若干个子问题，先求解子问题，然后由这些子问题的解再得到原问题的解。

核心：'记住求过的解来节省时间'，
动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

求解的方式有两种：
    ①自顶向下的备忘录法
    ②自底向上。
'''

# class Solution:
#     def trip(city_n, money):
#         for i in range(city_n):


'''
参考，位验证是否可行
if __name__ == "__main__":
    n=int(input())
    m=[]
    for i in range(n):
        m.append(list(map(int,input().split())))
    s=0
    past=set()
    past.add((0,0))
    for i in range(1,n):
        a,b=0,0
        cost=m[i][a]+m[i][b]
        for p in past:
            c=m[p[0]][i]+m[p[1]][i]-m[p[0]][p[1]]
            if(c < cost):
                a=p[0]
                b=p[1]
                cost=c
        s+=cost
        past.remove((a,b))
        past.add((a,i))
        past.add((i,a))
    print(s)

'''
