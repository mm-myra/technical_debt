https://pythonguidecn.readthedocs.io/zh/latest/writing/style.html

## 明确的代码
在存在各种黑魔法的Python中，我们提倡最明确和直接的编码方式。
 - 糟糕
```python
def make_complex(*args):
    x, y = args
    return dict(**locals())
```
 - 优雅
```python
def make_complex(x, y):
    return {'x': x, 'y': y}
```
在上述优雅的代码中，x和y以明确的字典形式返回给调用者。开发者在使用 这个函数的时候通过阅读第一和最后一行，能够正确地知道该做什么。而在 糟糕的例子中则没有那么明确。
### 每行一个声明
复合语句（比如说列表推导）因其简洁和表达性受到推崇，但在同一行代码中写 两条独立的语句是糟糕的。

 - 糟糕
```python
print 'one'; print 'two'

if x == 1: print 'one'

if <complex comparison> and <other complex comparison>:
    # do something
```
 - 优雅

```python
print 'one'
print 'two'

if x == 1:
    print 'one'

cond1 = <complex comparison>
cond2 = <other complex comparison>
if cond1 and cond2:
    # do something
```

### 函数参数

将参数传递给函数有四种不同的方式：

#### <strong>1.位置参数</strong>

<strong>是强制的，且没有默认值。</strong> 它们是最简单的参数形式，而且能被用在 一些这样的函数参数中：它们是函数意义的完整部分，其顺序是自然的。比如说：对 函数的使用者而言，记住 send(message, recipient) 或 point(x, y) 需要 两个参数以及它们的参数顺序并不困难。  

在这两种情况下，当调用函数的时候可以使用参数名称，也可以改变参数的顺序，比如说 send(recipient='World', message='Hello') 和 point(y=2, x=1)。但和 send( 'Hello', 'World') 和 point(1, 2) 比起来，这降低了可读性，而且带来了 不必要的冗长。

#### <strong>2.关键字参数</strong>

<strong>是非强制的，且有默认值。</strong>它们经常被用在传递给函数的可选参数中。 当一个函数有超过两个或三个位置参数时，函数签名会变得难以记忆，使用带有默认参数 的关键字参数将会带来帮助。比如，一个更完整的 send 函数可以被定义为 send(message, to, cc=None, bcc=None)。这里的 cc 和 bcc 是可选的， 当没有传递给它们其他值的时候，它们的值就是None。

#### <strong>3.任意参数列表</strong>

<strong>如果函数的目的通过带有数目可扩展的 位置参数的签名能够更好的表达，该函数可以被定义成 *args 的结构。</strong>在这个函数体中， args 是一个元组，它包含所有剩余的位置参数。举个例子， 我们可以用任何容器作为参数去 调用 send(message, *args) ，比如 send('Hello', 'God', 'Mom', 'Cthulhu')。 在此函数体中， args 相当于 ('God','Mom', 'Cthulhu')。  

尽管如此，这种结构有一些缺点，使用时应该予以注意。如果一个函数接受的参数列表具有 相同的性质，通常把它定义成一个参数，这个参数是一个列表或者其他任何序列会更清晰。 在这里，如果 send 参数有多个容器（recipients），将之定义成 send(message, recipients) 会更明确，调用它时就使用 send('Hello', ['God', 'Mom', 'Cthulhu'])。这样的话， 函数的使用者可以事先将容器列表维护成列表（list）形式，这为传递各种不能被转变成 其他序列的序列（包括迭代器）带来了可能。

#### <strong>4.任意关键字参数字典</strong>

如果函数要求一系列待定的 命名参数，我们可以使用 **kwargs 的结构。在函数体中， kwargs 是一个 字典，它包含所有传递给函数但没有被其他关键字参数捕捉的命名参数。  

和 任意参数列表 中所需注意的一样，相似的原因是：这些强大的技术是用在被证明确实 需要用到它们的时候，它们不应该被用在能用更简单和更明确的结构，来足够表达函数意图 的情况中。  

编写函数的时候采用何种参数形式，是用位置参数，还是可选关键字参数，是否使用形如任意参数 的高级技术，这些都由程序员自己决定。如果能明智地遵循上述建议，就可能且非常享受地写出 这样的Python函数：
 - 易读（名字和参数无需解释）
 - 易改（添加新的关键字参数不会破坏代码的其他部分）


### 避免魔法方法

Python 对骇客来说是一个强有力的工具，它拥有非常丰富的钩子（hook）和工具，允许 您施展几乎任何形式的技巧。比如说，它能够做以下每件事：
 - 改变对象创建和实例化的方式
 - 改变Python解释器导入模块的方式

甚至可能（如果需要的话也是被推荐的）在Python中嵌入C程序
尽管如此，所有的这些选择都有许多缺点。使用更加直接的方式来达成目标通常是更好的 方法。它们最主要的缺点是可读性不高。许多代码分析工具，比如说 pylint 或者 pyflakes，将无法解析这种“魔法”代码。

我们认为Python开发者应该知道这些近乎无限的可能性，因为它为我们灌输了没有不可能 完成的任务的信心。然而，知道如何，尤其是何时 不能 使用它们是非常重要的。

就像一位功夫大师，一个Pythonista知道如何用一个手指杀死对方，但从不会那么去做。

### 我们都是负责任的用户

如前所述，Python允许很多技巧，其中一些具有潜在的危险。一个好的例子是：任何客户端 代码能够重写一个对象的属性和方法（Python中没有 “private” 关键字）。这种哲学 是在说：“我们都是负责任的用户”，它和高度防御性的语言（如Java，拥有很多机制来预防 错误的使用）有着非常大的不同。

这并不意味着，比如说，<strong>Python中没有属性是私有的，也不意味着没有合适的封装方法。 </strong>与其依赖在开发者的代码之间树立起的一道道隔墙，Python社区更愿意依靠一组约定，来表明这些元素不应该被直接访问。

<strong>私有属性的主要约定和实现细节是在所有的“内部”变量前加一个下划线。</strong>如果客户端代码打破了这条规则并访问了带有下划线的变量，那么因内部代码的改变而出现的任何不当的行为或问题，都是客户端代码的责任。

鼓励“慷慨地”使用此约定：任何不开放给客户端代码使用的方法或属性，应该有一个下划线前缀。这将保证更好的职责划分以及更容易对已有代码进行修改。将一个私有属性公开化总是可能的，但是把一个公共属性私有化可能是一个更难的选择。

### 返回值

当一个函数变得复杂，在函数体中使用多返回值的语句并不少见。然而，为了保持函数的明确意图以及一个可持续的可读水平，更建议在函数体中避免使用返回多个有意义的值。

在函数中返回结果主要有两种情况：函数正常运行并返回它的结果，以及错误的情况，要么 因为一个错误的输入参数，要么因为其他导致函数无法完成计算或任务的原因。

如果您在面对第二种情况时不想抛出异常，返回一个值（比如说None或False）来表明函数无法正确运行，可能是需要的。在这种情况下，越早返回所发现的不正确上下文越好。 这将帮助扁平化函数的结构：在“因为错误而返回”的语句后的所有代码能够假定条件满足接下来的函数主要结果的运算。有多个这样的返回结果通常是需要的。

尽管如此，当一个函数在其正常过程中有多个主要出口点时，它会变得难以调试和返回其 结果，所以保持单个出口点可能会更好。这也将有助于提取某些代码路径，而且多个出口点很有可能意味着这里需要重构。

``` python
def complex_function(a, b, c):
    if not a:
        return None  # 抛出一个异常可能会更好
    if not b:
        return None  # 抛出一个异常可能会更好

    # 一些复杂的代码试着用a,b,c来计算x
    # 如果成功了，抵制住返回x的诱惑
    if not x:
        # 一些关于x的计算的Plan-B
    return x  # 返回值x只有一个出口点有利于维护代码
```